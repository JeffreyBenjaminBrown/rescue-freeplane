* TODO references (in order)
Next skip to ArrowTree.
** DONE tutorial
https://www.vex.net/~trebla/haskell/hxt-arrow/lesson-1.xhtml
** DONE Control.Category
** DONE Control.Arrow
** Control.Arrow.ArrowList
resume at listA
** Control.Arrow.ArrowIf
** Control.Arrow.ArrowTree
** Text.XML.HXT.Arrow.XmlArrow
* TODO convert .mm to .org
** some Xml-specific functions
https://hackage.haskell.org/package/hxt-9.3.1.18/docs/Text-XML-HXT-Arrow-XmlArrow.html

eelem :: String -> a n XmlTree
addAttr :: String -> String -> a XmlTree XmlTree
mkName :: String -> QName

getAttrValue :: String -> a XmlTree String

(+=) :: a b XmlTree -> a b XmlTree -> a b XmlTree
  adds children
aelem :: String -> [a n XmlTree] -> a n XmlTree
  with attributes and no content
mkElement :: QName -> a n XmlTree -> a n XmlTree -> a n XmlTree
  I'm guessing the first arrow is attributes, the second children.
mkqelem :: QName -> [a n XmlTree] -> [a n XmlTree] -> a n XmlTree
  "more comfortable than mkElement"
mkAttr :: QName -> a n XmlTree -> a n XmlTree
  If `mkAttr q f == r`, I believe `r` will apply `f` to its input
  to create the attribute value, whereas `q` is the attribute name.
mkelem :: String -> [a n XmlTree] -> [a n XmlTree] -> a n XmlTree
  Uses strings instead of qualified names as element names.

txt :: String -> a n XmlTree

getElemName :: a XmlTree QName
getAttrl :: a XmlTree XmlTree
getAttrName :: a XmlTree QName
getAttrValue0 :: String -> a XmlTree String
setElemName :: QName -> a XmlTree XmlTree
setAttrl :: a XmlTree XmlTree -> a XmlTree XmlTree
addAttrl :: a XmlTree XmlTree -> a XmlTree XmlTree
** component routines
*** apply condition
Mine.getDeepest_xTags
Mine.getHighest_xTags
*** delete if condition holds
Mine.deleteIf
*** delete if condition holds, preserving tree structure
Mine.deleteIf_blank_bottomUp
*** replace something with its children
Mine.replaceWithChildren_ifX
*** transform XText (leaf) to XTag (tree)
Mine.textToNode
*** tag all leaves
Mine.tagLeaves
*** get an attribute
Mine.getTextAttrs
*** print org-style
Use an arrow with an Int arg that has effects.
It calls itself, augmenting the Int arg, on children.
** recipe
*** step 1: strip
 Delete each XTag "head".
 Delete each XText that contains nothing but whitespace (including "\n").
 Replace each Xtag "html|body|p" with its children.
 For each XTag "node",
   strip all of its tags except its TEXT value,
   and keep its children in place.
*** step 2 (???) : from .xml to .mm
* PITFALL: read (in Hxt) mangles the data a little by default
Character references, entity references, and CDATA nodes are converted and merged into text nodes. Comments and the DTD are discarded. These features can be turned off by certain options of readDocument or in some cases by calling some other read/parse functions instead.
* about the data format
** navigate the tree
with getChildren and filters
** "elements"
are things between <>, e.g. "<head>" is an element.
Filter for them with "isElem".
** the "name" of an element
In the tutorial sample data,
it's whatever comes between the <> symbols,
but they are always single words.
I suspect the name is only the first of those words.
Filter for it with "hasName".
** "text"
is outside of angle brackets.
It matters in the .mm data because of the "richcontent" elements.
