* PITFALL: the freeplane format changed over time
In particular, the set of tags used might be different.
This code is based on freeplane 1.6.0,
which might be the newest.
* TODO change org colors
* references (in order)
Next skip to ArrowTree.
** DONE tutorial
https://www.vex.net/~trebla/haskell/hxt-arrow/lesson-1.xhtml
** DONE Control.Category
** DONE Control.Arrow
** Control.Arrow.ArrowList
resume at listA
** Control.Arrow.ArrowIf
** Control.Arrow.ArrowTree
** Text.XML.HXT.Arrow.XmlArrow
* TODO convert .mm to .org
** some Xml-specific functions
https://hackage.haskell.org/package/hxt-9.3.1.18/docs/Text-XML-HXT-Arrow-XmlArrow.html

eelem :: String -> a n XmlTree
addAttr :: String -> String -> a XmlTree XmlTree
mkName :: String -> QName

getAttrValue :: String -> a XmlTree String

(+=) :: a b XmlTree -> a b XmlTree -> a b XmlTree
  adds children
aelem :: String -> [a n XmlTree] -> a n XmlTree
  with attributes and no content
mkElement :: QName -> a n XmlTree -> a n XmlTree -> a n XmlTree
  I'm guessing the first arrow is attributes, the second children.
mkqelem :: QName -> [a n XmlTree] -> [a n XmlTree] -> a n XmlTree
  "more comfortable than mkElement"
mkAttr :: QName -> a n XmlTree -> a n XmlTree
  If `mkAttr q f == r`, I believe `r` will apply `f` to its input
  to create the attribute value, whereas `q` is the attribute name.
mkelem :: String -> [a n XmlTree] -> [a n XmlTree] -> a n XmlTree
  Uses strings instead of qualified names as element names.

txt :: String -> a n XmlTree

getElemName :: a XmlTree QName
getAttrl :: a XmlTree XmlTree
getAttrName :: a XmlTree QName
getAttrValue0 :: String -> a XmlTree String
setElemName :: QName -> a XmlTree XmlTree
setAttrl :: a XmlTree XmlTree -> a XmlTree XmlTree
addAttrl :: a XmlTree XmlTree -> a XmlTree XmlTree
** component routines
*** apply condition
Mine.getDeepest_xTags
Mine.getHighest_xTags
*** delete if condition holds
Mine.deleteIf
*** delete if condition holds, preserving tree structure
Mine.deleteIf_blank_bottomUp
*** replace something with its children
Mine.replaceWithChildren_ifX
*** transform XText (leaf) to XTag (tree)
Mine.textToNode
*** tag all leaves
Mine.tagLeaves
*** get an attribute
Mine.getTextAttrs
*** print org-style
Use an arrow with an Int arg that has effects.
It calls itself, augmenting the Int arg, on children.
** recipe
*** consider all tags
found via Research.allTags
**** node (print)
**** SOMEDAY ? arrowlink
**** SOMEDAY ? font
**** / (descend)
**** map (descend)
**** body (descend)
**** html (descend)
**** p (descend)
**** richcontent (descend)
**** edge (skip)
**** head (skip)
**** hook (skip)
**** properties (skip)

https://emacs.stackexchange.com/questions/26781/customize-colors-of-level-in-org-mode
* TODO ? remove unnecessary stars
** use arrow notation
https://stackoverflow.com/questions/59867382/haskell-arrows-on-trees-xml-and-hxt-transform-text-leaves-into-subtrees/59869915#59869915
https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/arrow-notation.html
** some code I wrote before I knew about that
  Control.Arrow.ArrowList.>. :: a b c -> ([c] -> d) -> a b d

  isBlankNode :: IOSArrow XmlTree XmlTree
  isBlankNode =
    isElem >>> hasName "node" >>>
    ( ifA ( getAttrValue "TEXT"
            >>> arrL (\case "" -> []; _ -> [()]) )
      returnA none )
* PITFALL: read (in Hxt) mangles the data a little by default
Character references, entity references, and CDATA nodes are converted and merged into text nodes. Comments and the DTD are discarded. These features can be turned off by certain options of readDocument or in some cases by calling some other read/parse functions instead.
* about the data format
** navigate the tree
with getChildren and filters
** "elements"
are things between <>, e.g. "<head>" is an element.
Filter for them with "isElem".
** the "name" of an element
In the tutorial sample data,
it's whatever comes between the <> symbols,
but they are always single words.
I suspect the name is only the first of those words.
Filter for it with "hasName".
** "text"
is outside of angle brackets.
It matters in the .mm data because of the "richcontent" elements.
